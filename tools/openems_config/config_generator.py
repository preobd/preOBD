"""
Generates the static config.h block and handles file I/O.
"""
import os
import re
import datetime
from typing import List, Dict, Any, Optional

def generate_static_calibrations_file(inputs: List[Dict[str, Any]], tool_version="1.0.0") -> Optional[str]:
    """
    Generates the static_calibrations.h file content for custom calibrations.
    Returns None if no custom calibrations are defined.

    Parses unified v1 format: calibration.type, calibration.source, calibration.params
    """
    # Check if any inputs have custom calibrations
    inputs_with_calibrations = [inp for inp in inputs if 'calibration' in inp]
    if not inputs_with_calibrations:
        return None

    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Map unified type strings to C++ struct names
    type_to_struct = {
        "THERMISTOR_STEINHART": "ThermistorSteinhartCalibration",
        "PRESSURE_LINEAR": "LinearCalibration",
        "PRESSURE_POLYNOMIAL": "PolynomialCalibration",
        "RPM": "RPMCalibration"
    }

    # Map camelCase params to snake_case C++ fields
    def map_params(cal_type: str, params: Dict[str, Any]) -> Dict[str, Any]:
        if cal_type == "THERMISTOR_STEINHART":
            return {
                "bias_resistor": params.get("biasResistor"),
                "steinhart_a": params.get("steinhartA"),
                "steinhart_b": params.get("steinhartB"),
                "steinhart_c": params.get("steinhartC")
            }
        elif cal_type == "PRESSURE_LINEAR":
            return {
                "voltage_min": params.get("voltageMin"),
                "voltage_max": params.get("voltageMax"),
                "pressure_min": params.get("pressureMin"),
                "pressure_max": params.get("pressureMax")
            }
        elif cal_type == "PRESSURE_POLYNOMIAL":
            return {
                "bias_resistor": params.get("biasResistor"),
                "poly_a": params.get("polyA"),
                "poly_b": params.get("polyB"),
                "poly_c": params.get("polyC")
            }
        elif cal_type == "RPM":
            return {
                "poles": params.get("poles"),
                "pulley_ratio": params.get("pulleyRatio"),
                "calibration_mult": params.get("calibrationMult"),
                "timeout_ms": params.get("timeoutMs"),
                "min_rpm": params.get("minRpm"),
                "max_rpm": params.get("maxRpm")
            }
        return {}

    header = f"""// Auto-generated by tools/configure.py v{tool_version} on {timestamp}
// DO NOT EDIT MANUALLY - Use tools/configure.py to regenerate

#ifndef STATIC_CALIBRATIONS_H
#define STATIC_CALIBRATIONS_H

#include "../sensor_types.h"
#include "../../config.h"

"""

    calibration_blocks = []
    for inp in inputs_with_calibrations:
        cal = inp['calibration']
        input_num = inp['input_number']
        app_name = inp.get('application', 'NONE')
        cal_type = cal.get('type', 'UNKNOWN')
        cal_source = cal.get('source', 'UNKNOWN')

        # Only generate custom calibrations
        if cal_source != 'CUSTOM':
            continue

        struct_name = type_to_struct.get(cal_type, 'UnknownCalibration')
        params = cal.get('params', {})
        mapped_params = map_params(cal_type, params)

        cal_block = f"""// Input {input_num}: {app_name} Custom Calibration
#define INPUT_{input_num}_CUSTOM_CALIBRATION
#ifdef INPUT_{input_num}_CUSTOM_CALIBRATION
    static const PROGMEM {struct_name} input_{input_num}_custom_cal = {{
"""

        for key, value in mapped_params.items():
            cal_block += f"        .{key} = {value},\n"

        cal_block += "    };\n#endif\n\n"
        calibration_blocks.append(cal_block)

    if not calibration_blocks:
        return None

    footer = "#endif // STATIC_CALIBRATIONS_H\n"
    return header + "".join(calibration_blocks) + footer

def generate_config_block(inputs: List[Dict[str, Any]], platform: str, tool_version="1.0.0") -> str:
    """
    Generates the C++ block for static sensor configuration.
    """
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    header = f"""
// ============================================================================
// STATIC SENSOR CONFIGURATION
// Generated by openEMS-config v{tool_version} on {timestamp}
// Platform: {platform}
// DO NOT EDIT MANUALLY - Use tools/configure.py to regenerate
// ============================================================================

#define NUM_CONFIGURED_INPUTS {len(inputs)}
"""

    input_defines = []
    for i, input_config in enumerate(inputs):
        app_name = input_config.get('application', 'NONE')
        sensor_name = input_config.get('sensor', 'NONE')

        define_block = f"""
// ----- Input {i}: {app_name} -----
#define INPUT_{i}_PIN           {input_config['pin']:<12}
#define INPUT_{i}_APPLICATION   {input_config['application_index']:<12} // {app_name}
#define INPUT_{i}_SENSOR        {input_config['sensor_index']:<12} // {sensor_name}
"""
        input_defines.append(define_block)

    return header + "".join(input_defines)

def write_static_calibrations_file(output_path: str, content: str) -> bool:
    """
    Writes the static_calibrations.h file to disk.
    Returns True on success, False on failure.
    """
    try:
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        with open(output_path, 'w') as f:
            f.write(content)
        return True
    except IOError:
        return False

def update_config_h(config_h_path: str, new_block: str) -> bool:
    """
    Surgically replaces the static config block in config.h and creates a backup.
    Returns True on success, False on failure.
    """
    try:
        with open(config_h_path, 'r') as f:
            content = f.read()

        with open(config_h_path + ".bak", 'w') as f:
            f.write(content)

        start_marker = "#ifdef USE_STATIC_CONFIG"
        end_marker = "#endif // USE_STATIC_CONFIG"

        start_index = content.find(start_marker)
        end_index = content.find(end_marker)

        if start_index != -1 and end_index != -1:
            pre_block = content[:start_index + len(start_marker)]
            post_block = content[end_index:]
            new_content = pre_block + "\n" + new_block + "\n" + post_block
        else:
            final_endif_index = content.rfind("#endif")
            if final_endif_index != -1:
                pre_block = content[:final_endif_index]
                post_block = content[final_endif_index:]
                new_content = pre_block + start_marker + "\n" + new_block + "\n" + end_marker + "\n\n" + post_block
            else:
                new_content = content + "\n" + start_marker + "\n" + new_block + "\n" + end_marker + "\n"

        with open(config_h_path, 'w') as f:
            f.write(new_content)

        return True

    except IOError:
        return False

def add_thin_library_header(content: str, library_type: str, tool_version: str) -> str:
    """
    Replaces the file header with a data-only thin library header.

    Args:
        content: The file content to modify
        library_type: "sensor" or "application"
        tool_version: Version of the tool generating the file

    Returns:
        Content with updated header
    """
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    if library_type == "sensor":
        header = f"""/*
 * sensor_library_static.h - Thin Sensor Library
 * Auto-generated by tools/configure.py v{tool_version} on {timestamp}
 * DO NOT EDIT MANUALLY - Use tools/configure.py to regenerate
 *
 * This is a thinned library containing only the configured sensors:
 * - Struct definitions (SensorInfo)
 * - PSTR macros (filtered to used sensors only)
 * - Sensor array (filtered to used sensors only)
 * - NUM_SENSORS constant
 * - Helper functions (kept for compatibility)
 *
 * Savings come from filtering unused sensor data, not removing helper functions.
 */
"""
    else:  # application
        header = f"""/*
 * application_presets_static.h - Thin Application Library
 * Auto-generated by tools/configure.py v{tool_version} on {timestamp}
 * DO NOT EDIT MANUALLY - Use tools/configure.py to regenerate
 *
 * This is a thinned library containing only the configured applications:
 * - Struct definitions (ApplicationPreset)
 * - PSTR macros (filtered to used applications only)
 * - Application array (filtered to used applications only)
 * - NUM_APPLICATION_PRESETS constant
 * - Helper functions (kept for compatibility)
 *
 * Savings come from filtering unused application data, not removing helper functions.
 */
"""

    # Find the end of the file comment block (look for */)
    comment_end = content.find('*/')
    if comment_end != -1:
        # Replace everything from start to end of comment
        return header + content[comment_end + 2:].lstrip()
    return header + content

def generate_thin_library_files(
    inputs: List[Dict[str, Any]],
    sensors: List[Dict[str, Any]],
    applications: List[Dict[str, Any]],
    output_dir: str,
    project_dir: str
):
    """
    Generates thinned sensor and application library files, including only the
    PSTR macros and struct definitions that are actually used.
    """
    os.makedirs(output_dir, exist_ok=True)

    # Get tool version from configure.py if available
    tool_version = "1.0.0"

    used_sensor_indices = {inp['sensor_index'] for inp in inputs}
    used_application_indices = {inp['application_index'] for inp in inputs}
    used_sensor_indices.add(0)
    used_application_indices.add(0)

    # Collect all required PSTR macros from the used sensors and applications
    required_pstr_macros = set()
    for sensor in sensors:
        if sensor['index'] in used_sensor_indices:
            required_pstr_macros.update(sensor['used_pstr_macros'])
    for app in applications:
        if app['index'] in used_application_indices:
            required_pstr_macros.update(app['used_pstr_macros'])

    # --- Generate thinned sensor library ---
    with open(os.path.join(project_dir, 'src/lib/sensor_library.h'), 'r') as f:
        sensor_template = f.read()

    # Fix include paths for the new location
    sensor_template = re.sub(r'#include "\.\./', r'#include "../../', sensor_template)
    sensor_template = re.sub(r'#include "([^./].*?)"', r'#include "../\1"', sensor_template)

    pstr_def_pattern = re.compile(r'static const char (PSTR_\w+)\[\] PROGMEM = ".*?";')
    kept_pstr_defs = "\n".join(
        match.group(0) for match in pstr_def_pattern.finditer(sensor_template)
        if match.group(1) in required_pstr_macros
    )

    start_marker = "// ===== STRING LITERALS IN PROGMEM ====="
    end_marker = "// ===== SENSOR LIBRARY (PROGMEM - Flash Memory) ====="
    thinned_template = re.sub(
        rf'{re.escape(start_marker)}.*?{re.escape(end_marker)}',
        f'{start_marker}\n{kept_pstr_defs}\n\n{end_marker}',
        sensor_template,
        flags=re.DOTALL
    )

    sensor_structs_str = ",\n".join(
        s['raw_c_block'] for s in sorted(sensors, key=lambda x: x['index']) if s['index'] in used_sensor_indices
    )

    thinned_sensor_content = re.sub(
        r'(static const PROGMEM SensorInfo SENSOR_LIBRARY\[\] = \{)(.*?)(\};)',
        f'\\1\n{sensor_structs_str}\n\\3',
        thinned_template,
        flags=re.DOTALL
    )

    # NOTE: We keep helper functions in thin libraries for now
    # TODO: In the future, only remove hash-based lookup functions (only needed for EEPROM mode)
    # helper_start = "// ===== HELPER FUNCTIONS ====="
    # helper_end = "// ===== END HELPER FUNCTIONS ====="
    # if helper_start in thinned_sensor_content and helper_end in thinned_sensor_content:
    #     start_idx = thinned_sensor_content.find(helper_start)
    #     end_idx = thinned_sensor_content.find(helper_end)
    #     pre = thinned_sensor_content[:start_idx]
    #     post_idx = thinned_sensor_content.find('\n#endif', end_idx)
    #     post = thinned_sensor_content[post_idx:] if post_idx != -1 else '\n#endif\n'
    #     thinned_sensor_content = pre.rstrip() + '\n\n' + post

    # Add data-only header
    thinned_sensor_content = add_thin_library_header(thinned_sensor_content, "sensor", tool_version)

    with open(os.path.join(output_dir, 'sensor_library_static.h'), 'w') as f:
        f.write(thinned_sensor_content)

    # --- Generate thinned application library ---
    with open(os.path.join(project_dir, 'src/lib/application_presets.h'), 'r') as f:
        app_template = f.read()

    # Fix include paths for the new location
    app_template = re.sub(r'#include "\.\./', r'#include "../../', app_template)
    app_template = re.sub(r'#include "([^./].*?)"', r'#include "../\1"', app_template)

    kept_pstr_defs = "\n".join(
        match.group(0) for match in pstr_def_pattern.finditer(app_template)
        if match.group(1) in required_pstr_macros
    )

    start_marker = "// ===== STRING LITERALS IN PROGMEM ====="
    end_marker = "// ===== APPLICATION PRESETS (PROGMEM - Flash Memory) ====="
    thinned_template = re.sub(
        rf'{re.escape(start_marker)}.*?{re.escape(end_marker)}',
        f'{start_marker}\n{kept_pstr_defs}\n\n{end_marker}',
        app_template,
        flags=re.DOTALL
    )

    app_structs_str = ",\n".join(
        a['raw_c_block'] for a in sorted(applications, key=lambda x: x['index']) if a['index'] in used_application_indices
    )

    thinned_app_content = re.sub(
        r'(static const PROGMEM ApplicationPreset APPLICATION_PRESETS\[\] = \{)(.*?)(\};)',
        f'\\1\n{app_structs_str}\n\\3',
        thinned_template,
        flags=re.DOTALL
    )

    # NOTE: We keep helper functions in thin libraries for now
    # TODO: In the future, only remove hash-based lookup functions (only needed for EEPROM mode)
    # if helper_start in thinned_app_content and helper_end in thinned_app_content:
    #     start_idx = thinned_app_content.find(helper_start)
    #     end_idx = thinned_app_content.find(helper_end)
    #     pre = thinned_app_content[:start_idx]
    #     post_idx = thinned_app_content.find('\n#endif', end_idx)
    #     post = thinned_app_content[post_idx:] if post_idx != -1 else '\n#endif\n'
    #     thinned_app_content = pre.rstrip() + '\n\n' + post

    # Add data-only header
    thinned_app_content = add_thin_library_header(thinned_app_content, "application", tool_version)

    with open(os.path.join(output_dir, 'application_presets_static.h'), 'w') as f:
        f.write(thinned_app_content)
